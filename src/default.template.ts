/**
 * This file is generated by schema2ts
 * DO NOT modify it directly
 */
abstract class Helper {
    protected fetch = fetch
    protected _getJSON(o: string): any {
        try {
            return JSON.parse(o)
        } catch {
            return o
        }
    }
    protected _getQueryString(params: any): string {
        const esc = encodeURIComponent
        const cloned = { ...params }
        for (const i in cloned) {
            if (cloned[i] === undefined) { delete cloned[i] }
        }
        return Object.keys(cloned).map((k) => esc(k) + '=' + esc(cloned[k])).join('&')
    }
    protected Error = (data: any, response: Response): never => { throw { data, response } }
    protected _createFetchInit(
        url: string,
        init: RequestInit,
        data?: any,
        urlParam?: { [key: string]: string | number },
    ): [string, RequestInit] {
        const method = (init.method || 'GET').toUpperCase()
        if (urlParam) {
            for (const [key, obj] of Object.entries(urlParam)) {
                url = url.replace(`{${key}}`, obj.toString())
            }
        }
        if (method === 'GET') {
            return [url + '?' + this._getQueryString(data), init]
        } else if (method === 'POST' || method === 'PUT') {
            init.headers['Content-type'] = 'application/json'
            init.body = JSON.stringify(data)
        }
        return [url, init]
    }
    protected async _return<T>(response: Promise<Response>)
        : Promise<T & { __response__: Response }> {
        const res = await response
        const text = await res.text()
        if (!res.ok) { this.Error(this._getJSON(text), res) }

        const obj = this._getJSON(text)
        Object.defineProperty(obj, '__response__', { value: res })
        return obj
    }
}

export namespace API {
    // Interfaces will inject here
}
export default abstract class API extends Helper {
    // Code here
}
