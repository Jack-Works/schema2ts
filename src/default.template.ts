/* tslint:disable */
/**
 * This file is generated by schema2ts
 * 
 * DO NOT modify it directly
 */
;
// Metadata will inject here

/** The Helper class of schema2ts, contains lots of tool function */
export abstract class Helper {
    /** The way to send HTTP Request
     * 
     *  you can replace it with anything that has the same type of `window.fetch`
     *  like fetch polyfill or fake fetch used in unit test
     */
    protected fetch: typeof fetch = (x, y) => fetch(x, y)
    /** Parse JSON, return origin data when failed */
    protected _getJSON(o: string): any {
        try {
            return JSON.parse(o)
        } catch {
            return o
        }
    }
    /** Transform parameters object to something like a=b&c=d */
    protected _getQueryString(params: object): string {
        const esc = encodeURIComponent
        const cloned = { ...params }
        for (const i in cloned) {
            if (cloned[i] === undefined) { delete cloned[i] }
        }
        return Object.keys(cloned).map((k) => esc(k) + '=' + esc(cloned[k])).join('&')
    }
    /** The way to throw Error,
     *  you can replace it with something like ```e => throw e```
     *  if you are not happy with this default behavior (throw {data, response})
     */
    protected Error = (error: Error, data: any, response: Response): never => { throw { data, response } }
    /** Create fetch parameters */
    protected _createFetchInit(
        url: string,
        init: RequestInit,
        query?: object,
        bodyParams?: any,
        pathParams?: { [key: string]: string | number },
    ): [string, RequestInit] {
        const method = (init.method || 'GET').toUpperCase()
        if (pathParams) {
            for (const key in pathParams) {
                const obj = pathParams[key]
                url = url.replace(`{${key}}`, obj.toString())
            }
        }
        if (query) {
            url = url + '?' + this._getQueryString(query)
        }
        if (bodyParams) {
            init.headers = {
                'Content-type': 'application/json',
                ...(init.headers || {}),
            } as any
            init.body = JSON.stringify(bodyParams)
        }
        return [url, init]
    }
    /** Handle the return value */
    protected async _return<T>(response: Promise<Response>)
        : Promise<T & { __response__: Response }> {
        const res = await response
        const text = await res.text()
        if (!res.ok) { this.Error(new Error('Connection failed.'), this._getJSON(text), res) }

        const obj = this._getJSON(text)
        Object.defineProperty(obj, '__response__', { value: res })
        return obj
    }

    /** Invoke fetch request by Metadata_key and parameters */
    protected __<T = void>(
        _url: string, method: string, pathParams?: object,
        query?: object, bodyParams?: any,
    ) {
        const [url, init] = this._createFetchInit(
            _url,
            { method },
            query || {},
            bodyParams,
            pathParams as any,
        )
        return this._return<T>(this.fetch(url, init))
    }
}

/** API contains all complex Interfaces used by methods */
export namespace API {
    // Interfaces will inject here
}

export default abstract class API extends Helper {
    // Code here
}
